import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/fhirclient/lib/HttpError.js
var require_HttpError = __commonJS({
  "node_modules/fhirclient/lib/HttpError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var HttpError = class extends Error {
      constructor(response) {
        super(`${response.status} ${response.statusText}
URL: ${response.url}`);
        this.name = "HttpError";
        this.response = response;
        this.statusCode = response.status;
        this.status = response.status;
        this.statusText = response.statusText;
      }
      async parse() {
        if (!this.response.bodyUsed) {
          try {
            const type = this.response.headers.get("content-type") || "text/plain";
            if (type.match(/\bjson\b/i)) {
              let body = await this.response.json();
              if (body.error) {
                this.message += "\n" + body.error;
                if (body.error_description) {
                  this.message += ": " + body.error_description;
                }
              } else {
                this.message += "\n\n" + JSON.stringify(body, null, 4);
              }
            } else if (type.match(/^text\//i)) {
              let body = await this.response.text();
              if (body) {
                this.message += "\n\n" + body;
              }
            }
          } catch (_a) {
          }
        }
        return this;
      }
      toJSON() {
        return {
          name: this.name,
          statusCode: this.statusCode,
          status: this.status,
          statusText: this.statusText,
          message: this.message
        };
      }
    };
    exports.default = HttpError;
  }
});

// node_modules/fhirclient/lib/settings.js
var require_settings = __commonJS({
  "node_modules/fhirclient/lib/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SMART_KEY = exports.patientParams = exports.fhirVersions = exports.patientCompartment = void 0;
    exports.patientCompartment = ["Account", "AdverseEvent", "AllergyIntolerance", "Appointment", "AppointmentResponse", "AuditEvent", "Basic", "BodySite", "BodyStructure", "CarePlan", "CareTeam", "ChargeItem", "Claim", "ClaimResponse", "ClinicalImpression", "Communication", "CommunicationRequest", "Composition", "Condition", "Consent", "Coverage", "CoverageEligibilityRequest", "CoverageEligibilityResponse", "DetectedIssue", "DeviceRequest", "DeviceUseRequest", "DeviceUseStatement", "DiagnosticOrder", "DiagnosticReport", "DocumentManifest", "DocumentReference", "EligibilityRequest", "Encounter", "EnrollmentRequest", "EpisodeOfCare", "ExplanationOfBenefit", "FamilyMemberHistory", "Flag", "Goal", "Group", "ImagingManifest", "ImagingObjectSelection", "ImagingStudy", "Immunization", "ImmunizationEvaluation", "ImmunizationRecommendation", "Invoice", "List", "MeasureReport", "Media", "MedicationAdministration", "MedicationDispense", "MedicationOrder", "MedicationRequest", "MedicationStatement", "MolecularSequence", "NutritionOrder", "Observation", "Order", "Patient", "Person", "Procedure", "ProcedureRequest", "Provenance", "QuestionnaireResponse", "ReferralRequest", "RelatedPerson", "RequestGroup", "ResearchSubject", "RiskAssessment", "Schedule", "ServiceRequest", "Specimen", "SupplyDelivery", "SupplyRequest", "VisionPrescription"];
    exports.fhirVersions = {
      "0.4.0": 2,
      "0.5.0": 2,
      "1.0.0": 2,
      "1.0.1": 2,
      "1.0.2": 2,
      "1.1.0": 3,
      "1.4.0": 3,
      "1.6.0": 3,
      "1.8.0": 3,
      "3.0.0": 3,
      "3.0.1": 3,
      "3.3.0": 4,
      "3.5.0": 4,
      "4.0.0": 4,
      "4.0.1": 4
    };
    exports.patientParams = ["patient", "subject", "requester", "member", "actor", "beneficiary"];
    exports.SMART_KEY = "SMART_KEY";
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/fhirclient/lib/lib.js
var require_lib = __commonJS({
  "node_modules/fhirclient/lib/lib.js"(exports) {
    "use strict";
    var __rest = function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertJsonPatch = exports.assert = exports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.getTimeInFuture = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.loweCaseKeys = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;
    var HttpError_1 = require_HttpError();
    var settings_1 = require_settings();
    var debug = require_browser();
    var {
      fetch
    } = typeof FHIRCLIENT_PURE !== "undefined" ? window : require_browser_ponyfill();
    var _debug = debug("FHIR");
    exports.debug = _debug;
    var cache = {};
    exports.units = {
      cm({
        code,
        value
      }) {
        ensureNumerical({
          code,
          value
        });
        if (code == "cm") return value;
        if (code == "m") return value * 100;
        if (code == "in") return value * 2.54;
        if (code == "[in_us]") return value * 2.54;
        if (code == "[in_i]") return value * 2.54;
        if (code == "ft") return value * 30.48;
        if (code == "[ft_us]") return value * 30.48;
        throw new Error("Unrecognized length unit: " + code);
      },
      kg({
        code,
        value
      }) {
        ensureNumerical({
          code,
          value
        });
        if (code == "kg") return value;
        if (code == "g") return value / 1e3;
        if (code.match(/lb/)) return value / 2.20462;
        if (code.match(/oz/)) return value / 35.274;
        throw new Error("Unrecognized weight unit: " + code);
      },
      any(pq) {
        ensureNumerical(pq);
        return pq.value;
      }
    };
    function ensureNumerical({
      value,
      code
    }) {
      if (typeof value !== "number") {
        throw new Error("Found a non-numerical unit: " + value + " " + code);
      }
    }
    async function checkResponse(resp) {
      if (!resp.ok) {
        const error = new HttpError_1.default(resp);
        await error.parse();
        throw error;
      }
      return resp;
    }
    exports.checkResponse = checkResponse;
    function responseToJSON(resp) {
      return resp.text().then((text) => text.length ? JSON.parse(text) : "");
    }
    exports.responseToJSON = responseToJSON;
    function loweCaseKeys(obj) {
      if (!obj) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map((v) => v && typeof v === "object" ? loweCaseKeys(v) : v);
      }
      let out = {};
      Object.keys(obj).forEach((key) => {
        const lowerKey = key.toLowerCase();
        const v = obj[key];
        out[lowerKey] = v && typeof v == "object" ? loweCaseKeys(v) : v;
      });
      return out;
    }
    exports.loweCaseKeys = loweCaseKeys;
    function request(url, requestOptions = {}) {
      const {
        includeResponse
      } = requestOptions, options = __rest(requestOptions, ["includeResponse"]);
      return fetch(url, Object.assign(Object.assign({
        mode: "cors"
      }, options), {
        headers: Object.assign({
          accept: "application/json"
        }, loweCaseKeys(options.headers))
      })).then(checkResponse).then((res) => {
        const type = res.headers.get("content-type") + "";
        if (type.match(/\bjson\b/i)) {
          return responseToJSON(res).then((body) => ({
            res,
            body
          }));
        }
        if (type.match(/^text\//i)) {
          return res.text().then((body) => ({
            res,
            body
          }));
        }
        return {
          res
        };
      }).then(({
        res,
        body
      }) => {
        if (!body && res.status == 201) {
          const location2 = res.headers.get("location");
          if (location2) {
            return request(location2, Object.assign(Object.assign({}, options), {
              method: "GET",
              body: null,
              includeResponse
            }));
          }
        }
        if (includeResponse) {
          return {
            body,
            response: res
          };
        }
        if (body === void 0) {
          return res;
        }
        return body;
      });
    }
    exports.request = request;
    function getAndCache(url, requestOptions, force = false) {
      if (force || !cache[url]) {
        cache[url] = request(url, requestOptions);
        return cache[url];
      }
      return Promise.resolve(cache[url]);
    }
    exports.getAndCache = getAndCache;
    function fetchConformanceStatement(baseUrl = "/", requestOptions) {
      const url = String(baseUrl).replace(/\/*$/, "/") + "metadata";
      return getAndCache(url, requestOptions).catch((ex) => {
        throw new Error(`Failed to fetch the conformance statement from "${url}". ${ex}`);
      });
    }
    exports.fetchConformanceStatement = fetchConformanceStatement;
    function getPath(obj, path = "") {
      path = path.trim();
      if (!path) {
        return obj;
      }
      let segments = path.split(".");
      let result = obj;
      while (result && segments.length) {
        const key = segments.shift();
        if (!key && Array.isArray(result)) {
          return result.map((o) => getPath(o, segments.join(".")));
        } else {
          result = result[key];
        }
      }
      return result;
    }
    exports.getPath = getPath;
    function setPath(obj, path, value, createEmpty = false) {
      path.trim().split(".").reduce((out, key, idx, arr) => {
        if (out && idx === arr.length - 1) {
          out[key] = value;
        } else {
          if (out && out[key] === void 0 && createEmpty) {
            out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};
          }
          return out ? out[key] : void 0;
        }
      }, obj);
      return obj;
    }
    exports.setPath = setPath;
    function makeArray(arg) {
      if (Array.isArray(arg)) {
        return arg;
      }
      return [arg];
    }
    exports.makeArray = makeArray;
    function absolute(path, baseUrl) {
      if (path.match(/^http/)) return path;
      if (path.match(/^urn/)) return path;
      return String(baseUrl || "").replace(/\/+$/, "") + "/" + path.replace(/^\/+/, "");
    }
    exports.absolute = absolute;
    function randomString(strLength = 8, charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
      const result = [];
      const len = charSet.length;
      while (strLength--) {
        result.push(charSet.charAt(Math.floor(Math.random() * len)));
      }
      return result.join("");
    }
    exports.randomString = randomString;
    function jwtDecode(token, env) {
      const payload = token.split(".")[1];
      return payload ? JSON.parse(env.atob(payload)) : null;
    }
    exports.jwtDecode = jwtDecode;
    function getTimeInFuture(secondsAhead = 120, from) {
      return Math.floor(+(from || /* @__PURE__ */ new Date()) / 1e3 + secondsAhead);
    }
    exports.getTimeInFuture = getTimeInFuture;
    function getAccessTokenExpiration(tokenResponse, env) {
      const now = Math.floor(Date.now() / 1e3);
      if (tokenResponse.expires_in) {
        return now + tokenResponse.expires_in;
      }
      if (tokenResponse.access_token) {
        let tokenBody = jwtDecode(tokenResponse.access_token, env);
        if (tokenBody && tokenBody.exp) {
          return tokenBody.exp;
        }
      }
      return now + 300;
    }
    exports.getAccessTokenExpiration = getAccessTokenExpiration;
    function byCode(observations, property) {
      const ret = {};
      function handleCodeableConcept(concept, observation) {
        if (concept && Array.isArray(concept.coding)) {
          concept.coding.forEach(({
            code
          }) => {
            if (code) {
              ret[code] = ret[code] || [];
              ret[code].push(observation);
            }
          });
        }
      }
      makeArray(observations).forEach((o) => {
        if (o.resourceType === "Observation" && o[property]) {
          if (Array.isArray(o[property])) {
            o[property].forEach((concept) => handleCodeableConcept(concept, o));
          } else {
            handleCodeableConcept(o[property], o);
          }
        }
      });
      return ret;
    }
    exports.byCode = byCode;
    function byCodes(observations, property) {
      const bank = byCode(observations, property);
      return (...codes) => codes.filter((code) => code + "" in bank).reduce((prev, code) => prev.concat(bank[code + ""]), []);
    }
    exports.byCodes = byCodes;
    function getPatientParam(conformance, resourceType) {
      const resources = getPath(conformance, "rest.0.resource") || [];
      const meta = resources.find((r) => r.type === resourceType);
      if (!meta) {
        throw new Error(`Resource "${resourceType}" is not supported by this FHIR server`);
      }
      if (!Array.isArray(meta.searchParam)) {
        throw new Error(`No search parameters supported for "${resourceType}" on this FHIR server`);
      }
      if (resourceType == "Patient" && meta.searchParam.find((x) => x.name == "_id")) {
        return "_id";
      }
      const out = settings_1.patientParams.find((p) => meta.searchParam.find((x) => x.name == p));
      if (!out) {
        throw new Error("I don't know what param to use for " + resourceType);
      }
      return out;
    }
    exports.getPatientParam = getPatientParam;
    async function getTargetWindow(target, width = 800, height = 720) {
      if (typeof target == "function") {
        target = await target();
      }
      if (target && typeof target == "object") {
        return target;
      }
      if (typeof target != "string") {
        _debug("Invalid target type '%s'. Failing back to '_self'.", typeof target);
        return self;
      }
      if (target == "_self") {
        return self;
      }
      if (target == "_parent") {
        return parent;
      }
      if (target == "_top") {
        return top || self;
      }
      if (target == "_blank") {
        let error, targetWindow = null;
        try {
          targetWindow = window.open("", "SMARTAuthPopup");
          if (!targetWindow) {
            throw new Error("Perhaps window.open was blocked");
          }
        } catch (e) {
          error = e;
        }
        if (!targetWindow) {
          _debug("Cannot open window. Failing back to '_self'. %s", error);
          return self;
        } else {
          return targetWindow;
        }
      }
      if (target == "popup") {
        let error, targetWindow = null;
        try {
          targetWindow = window.open("", "SMARTAuthPopup", ["height=" + height, "width=" + width, "menubar=0", "resizable=1", "status=0", "top=" + (screen.height - height) / 2, "left=" + (screen.width - width) / 2].join(","));
          if (!targetWindow) {
            throw new Error("Perhaps the popup window was blocked");
          }
        } catch (e) {
          error = e;
        }
        if (!targetWindow) {
          _debug("Cannot open window. Failing back to '_self'. %s", error);
          return self;
        } else {
          return targetWindow;
        }
      }
      const winOrFrame = frames[target];
      if (winOrFrame) {
        return winOrFrame;
      }
      _debug("Unknown target '%s'. Failing back to '_self'.", target);
      return self;
    }
    exports.getTargetWindow = getTargetWindow;
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    exports.assert = assert;
    function assertJsonPatch(patch) {
      assert(Array.isArray(patch), "The JSON patch must be an array");
      assert(patch.length > 0, "The JSON patch array should not be empty");
      patch.forEach((operation) => {
        assert(["add", "replace", "test", "move", "copy", "remove"].indexOf(operation.op) > -1, 'Each patch operation must have an "op" property which must be one of: "add", "replace", "test", "move", "copy", "remove"');
        assert(operation.path && typeof operation.path, `Invalid "${operation.op}" operation. Missing "path" property`);
        if (operation.op == "add" || operation.op == "replace" || operation.op == "test") {
          assert("value" in operation, `Invalid "${operation.op}" operation. Missing "value" property`);
          assert(Object.keys(operation).length == 3, `Invalid "${operation.op}" operation. Contains unknown properties`);
        } else if (operation.op == "move" || operation.op == "copy") {
          assert(typeof operation.from == "string", `Invalid "${operation.op}" operation. Requires a string "from" property`);
          assert(Object.keys(operation).length == 3, `Invalid "${operation.op}" operation. Contains unknown properties`);
        } else {
          assert(Object.keys(operation).length == 2, `Invalid "${operation.op}" operation. Contains unknown properties`);
        }
      });
    }
    exports.assertJsonPatch = assertJsonPatch;
  }
});

// node_modules/fhirclient/lib/strings.js
var require_strings = __commonJS({
  "node_modules/fhirclient/lib/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      expired: "Session expired! Please re-launch the app",
      noScopeForId: "Trying to get the ID of the selected %s. Please add 'launch' or 'launch/%s' to the requested scopes and try again.",
      noIfNoAuth: "You are trying to get %s but the app is not authorized yet.",
      noFreeContext: "Please don't use open fhir servers if you need to access launch context items like the %S."
    };
  }
});

// node_modules/fhirclient/lib/FhirClient.js
var require_FhirClient = __commonJS({
  "node_modules/fhirclient/lib/FhirClient.js"(exports) {
    "use strict";
    var __asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({
            value: v2,
            done: d
          });
        }, reject);
      }
    };
    var __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    var __rest = function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var settings_1 = require_settings();
    var lib_1 = require_lib();
    var debug = lib_1.debug.extend("FhirClient");
    var FhirClient = class {
      /**
       * Validates the parameters, creates an instance and tries to connect it to
       * FhirJS, if one is available globally.
       */
      constructor(fhirBaseUrl) {
        (0, lib_1.assert)(fhirBaseUrl && typeof fhirBaseUrl === "string" && fhirBaseUrl.match(/https?:\/\/.+/), 'A "fhirBaseUrl" string parameter is required and must begin with "http(s)"');
        this.fhirBaseUrl = fhirBaseUrl;
      }
      /**
       * Creates a new resource in a server-assigned location
       * @see http://hl7.org/fhir/http.html#create
       * @param resource A FHIR resource to be created
       * @param [requestOptions] Any options to be passed to the fetch call.
       * Note that `method` and `body` will be ignored.
       * @category Request
       */
      async create(resource, requestOptions) {
        return this.fhirRequest(resource.resourceType, Object.assign(Object.assign({}, requestOptions), {
          method: "POST",
          body: JSON.stringify(resource),
          headers: Object.assign({
            "content-type": "application/json"
          }, (requestOptions || {}).headers)
        }));
      }
      /**
       * Creates a new current version for an existing resource or creates an
       * initial version if no resource already exists for the given id.
       * @see http://hl7.org/fhir/http.html#update
       * @param resource A FHIR resource to be updated
       * @param requestOptions Any options to be passed to the fetch call.
       * Note that `method` and `body` will be ignored.
       * @category Request
       */
      async update(resource, requestOptions) {
        return this.fhirRequest(`${resource.resourceType}/${resource.id}`, Object.assign(Object.assign({}, requestOptions), {
          method: "PUT",
          body: JSON.stringify(resource),
          headers: Object.assign({
            "content-type": "application/json"
          }, (requestOptions || {}).headers)
        }));
      }
      /**
       * Removes an existing resource.
       * @see http://hl7.org/fhir/http.html#delete
       * @param url Relative URI of the FHIR resource to be deleted
       * (format: `resourceType/id`)
       * @param requestOptions Any options (except `method` which will be fixed
       * to `DELETE`) to be passed to the fetch call.
       * @category Request
       */
      async delete(url, requestOptions = {}) {
        return this.fhirRequest(url, Object.assign(Object.assign({}, requestOptions), {
          method: "DELETE"
        }));
      }
      /**
       * Makes a JSON Patch to the given resource
       * @see http://hl7.org/fhir/http.html#patch
       * @param url Relative URI of the FHIR resource to be patched
       * (format: `resourceType/id`)
       * @param patch A JSON Patch array to send to the server, For details
       * see https://datatracker.ietf.org/doc/html/rfc6902
       * @param requestOptions Any options to be passed to the fetch call,
       * except for `method`, `url` and `body` which cannot be overridden.
       * @since 2.4.0
       * @category Request
       * @typeParam ResolveType This method would typically resolve with the
       * patched resource or reject with an OperationOutcome. However, this may
       * depend on the server implementation or even on the request headers.
       * For that reason, if the default resolve type (which is
       * [[fhirclient.FHIR.Resource]]) does not work for you, you can pass
       * in your own resolve type parameter.
       */
      async patch(url, patch, requestOptions = {}) {
        (0, lib_1.assertJsonPatch)(patch);
        return this.fhirRequest(url, Object.assign(Object.assign({}, requestOptions), {
          method: "PATCH",
          body: JSON.stringify(patch),
          headers: Object.assign({
            "prefer": "return=presentation",
            "content-type": "application/json-patch+json; charset=UTF-8"
          }, requestOptions.headers)
        }));
      }
      async resolveRef(obj, path, graph, cache, requestOptions = {}) {
        const node = (0, lib_1.getPath)(obj, path);
        if (node) {
          const isArray = Array.isArray(node);
          return Promise.all((0, lib_1.makeArray)(node).filter(Boolean).map((item, i) => {
            const ref = item.reference;
            if (ref) {
              return this.fhirRequest(ref, Object.assign(Object.assign({}, requestOptions), {
                includeResponse: false,
                cacheMap: cache
              })).then((sub) => {
                if (graph) {
                  if (isArray) {
                    if (path.indexOf("..") > -1) {
                      (0, lib_1.setPath)(obj, `${path.replace("..", `.${i}.`)}`, sub);
                    } else {
                      (0, lib_1.setPath)(obj, `${path}.${i}`, sub);
                    }
                  } else {
                    (0, lib_1.setPath)(obj, path, sub);
                  }
                }
              }).catch((ex) => {
                if ((ex === null || ex === void 0 ? void 0 : ex.status) === 404) {
                  console.warn(`Missing reference ${ref}. ${ex}`);
                } else {
                  throw ex;
                }
              });
            }
          }));
        }
      }
      /**
       * Fetches all references in the given resource, ignoring duplicates, and
       * then modifies the resource by "mounting" the resolved references in place
       */
      async resolveReferences(resource, references, requestOptions = {}) {
        await this.fetchReferences(resource, references, true, {}, requestOptions);
      }
      async fetchReferences(resource, references, graph, cache = {}, requestOptions = {}) {
        if (resource.resourceType == "Bundle") {
          for (const item of resource.entry || []) {
            if (item.resource) {
              await this.fetchReferences(item.resource, references, graph, cache, requestOptions);
            }
          }
          return cache;
        }
        let paths = references.map((path) => String(path).trim()).filter(Boolean);
        paths = paths.reduce((prev, cur) => {
          if (prev.includes(cur)) {
            debug('Duplicated reference path "%s"', cur);
          } else {
            prev.push(cur);
          }
          return prev;
        }, []);
        if (!paths.length) {
          return Promise.resolve(cache);
        }
        const groups = {};
        paths.forEach((path) => {
          const len = path.split(".").length;
          if (!groups[len]) {
            groups[len] = [];
          }
          groups[len].push(path);
        });
        let task = Promise.resolve();
        Object.keys(groups).sort().forEach((len) => {
          const group = groups[len];
          task = task.then(() => Promise.all(group.map((path) => {
            return this.resolveRef(resource, path, graph, cache, requestOptions);
          })));
        });
        await task;
        return cache;
      }
      /**
       * Fetches all references in the given resource, ignoring duplicates
       */
      async getReferences(resource, references, requestOptions = {}) {
        const refs = await this.fetchReferences(resource, references, false, {}, requestOptions);
        const out = {};
        for (const key in refs) {
          out[key] = await refs[key];
        }
        return out;
      }
      /**
       * Given a FHIR Bundle or a URL pointing to a bundle, iterates over all
       * entry resources. Note that this will also automatically crawl through
       * further pages (if any)
       */
      resources(bundleOrUrl, options) {
        return __asyncGenerator(this, arguments, function* resources_1() {
          var e_1, _a;
          let count = 0;
          try {
            for (var _b = __asyncValues(this.pages(bundleOrUrl, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
              const page = _c.value;
              for (const entry of page.entry || []) {
                if ((options === null || options === void 0 ? void 0 : options.limit) && ++count > options.limit) {
                  return yield __await(void 0);
                }
                yield yield __await(entry.resource);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        });
      }
      /**
       * Given a FHIR Bundle or a URL pointing to a bundle, iterates over all
       * pages. Note that this will automatically crawl through
       * further pages (if any) but it will not detect previous pages. It is
       * designed to be called on the first page and fetch any followup pages.
       */
      pages(bundleOrUrl, requestOptions) {
        var _a, _b;
        return __asyncGenerator(this, arguments, function* pages_1() {
          const _c = requestOptions || {}, {
            limit
          } = _c, options = __rest(_c, ["limit"]);
          const fetchPage = (url) => this.fhirRequest(url, options);
          let page = typeof bundleOrUrl === "string" || bundleOrUrl instanceof URL ? yield __await(fetchPage(bundleOrUrl)) : bundleOrUrl;
          let count = 0;
          while (page && page.resourceType === "Bundle" && (!limit || ++count <= limit)) {
            yield yield __await(page);
            if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
              break;
            }
            const nextLink = ((_b = page.link) !== null && _b !== void 0 ? _b : []).find((l) => l.relation === "next" && typeof l.url === "string");
            if (!nextLink) {
              break;
            }
            page = yield __await(fetchPage(nextLink.url));
          }
        });
      }
      /**
       * The method responsible for making all http requests
       */
      async fhirRequest(uri, options = {}) {
        (0, lib_1.assert)(options, "fhirRequest requires a uri as first argument");
        const path = uri + "";
        const url = (0, lib_1.absolute)(path, this.fhirBaseUrl);
        const {
          cacheMap
        } = options;
        if (cacheMap) {
          if (!(path in cacheMap)) {
            cacheMap[path] = (0, lib_1.request)(url, options).then((res) => {
              cacheMap[path] = res;
              return res;
            }).catch((error) => {
              delete cacheMap[path];
              throw error;
            });
          }
          return cacheMap[path];
        }
        return (0, lib_1.request)(url, options);
      }
      /**
       * Returns a promise that will be resolved with the fhir version as defined
       * in the CapabilityStatement.
       */
      async getFhirVersion() {
        return (0, lib_1.fetchConformanceStatement)(this.fhirBaseUrl).then((metadata) => metadata.fhirVersion);
      }
      /**
       * Returns a promise that will be resolved with the numeric fhir version
       * - 2 for DSTU2
       * - 3 for STU3
       * - 4 for R4
       * - 0 if the version is not known
       */
      async getFhirRelease() {
        return this.getFhirVersion().then((v) => {
          var _a;
          return (_a = settings_1.fhirVersions[v]) !== null && _a !== void 0 ? _a : 0;
        });
      }
    };
    exports.default = FhirClient;
  }
});

// node_modules/fhirclient/lib/Client.js
var require_Client = __commonJS({
  "node_modules/fhirclient/lib/Client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var lib_1 = require_lib();
    var strings_1 = require_strings();
    var settings_1 = require_settings();
    var FhirClient_1 = require_FhirClient();
    var {
      Response
    } = typeof FHIRCLIENT_PURE !== "undefined" ? window : require_browser_ponyfill();
    var debug = lib_1.debug.extend("client");
    async function contextualize(requestOptions, client) {
      const base = (0, lib_1.absolute)("/", client.state.serverUrl);
      async function contextualURL(_url) {
        const resourceType = _url.pathname.split("/").pop();
        (0, lib_1.assert)(resourceType, `Invalid url "${_url}"`);
        (0, lib_1.assert)(settings_1.patientCompartment.indexOf(resourceType) > -1, `Cannot filter "${resourceType}" resources by patient`);
        const conformance = await (0, lib_1.fetchConformanceStatement)(client.state.serverUrl);
        const searchParam = (0, lib_1.getPatientParam)(conformance, resourceType);
        _url.searchParams.set(searchParam, client.patient.id);
        return _url.href;
      }
      if (typeof requestOptions == "string" || requestOptions instanceof URL) {
        return {
          url: await contextualURL(new URL(requestOptions + "", base))
        };
      }
      requestOptions.url = await contextualURL(new URL(requestOptions.url + "", base));
      return requestOptions;
    }
    var Client = class extends FhirClient_1.default {
      /**
       * Validates the parameters, creates an instance and tries to connect it to
       * FhirJS, if one is available globally.
       */
      constructor(environment, state) {
        const _state = typeof state == "string" ? {
          serverUrl: state
        } : state;
        (0, lib_1.assert)(_state.serverUrl && _state.serverUrl.match(/https?:\/\/.+/), 'A "serverUrl" option is required and must begin with "http(s)"');
        super(_state.serverUrl);
        this.units = lib_1.units;
        this.state = _state;
        this.environment = environment;
        this._refreshTask = null;
        const client = this;
        this.patient = {
          get id() {
            return client.getPatientId();
          },
          read: (requestOptions) => {
            const id = this.patient.id;
            return id ? this.request(Object.assign(Object.assign({}, requestOptions), {
              url: `Patient/${id}`
            })) : Promise.reject(new Error("Patient is not available"));
          },
          request: (requestOptions, fhirOptions = {}) => {
            if (this.patient.id) {
              return (async () => {
                const options = await contextualize(requestOptions, this);
                return this.request(options, fhirOptions);
              })();
            } else {
              return Promise.reject(new Error("Patient is not available"));
            }
          }
        };
        this.encounter = {
          get id() {
            return client.getEncounterId();
          },
          read: (requestOptions) => {
            const id = this.encounter.id;
            return id ? this.request(Object.assign(Object.assign({}, requestOptions), {
              url: `Encounter/${id}`
            })) : Promise.reject(new Error("Encounter is not available"));
          }
        };
        this.user = {
          get fhirUser() {
            return client.getFhirUser();
          },
          get id() {
            return client.getUserId();
          },
          get resourceType() {
            return client.getUserType();
          },
          read: (requestOptions) => {
            const fhirUser = this.user.fhirUser;
            return fhirUser ? this.request(Object.assign(Object.assign({}, requestOptions), {
              url: fhirUser
            })) : Promise.reject(new Error("User is not available"));
          }
        };
        this.connect(environment.fhir);
      }
      /**
       * This method is used to make the "link" between the `fhirclient` and the
       * `fhir.js`, if one is available.
       * **Note:** This is called by the constructor. If fhir.js is available in
       * the global scope as `fhir`, it will automatically be linked to any [[Client]]
       * instance. You should only use this method to connect to `fhir.js` which
       * is not global.
       */
      connect(fhirJs) {
        if (typeof fhirJs == "function") {
          const options = {
            baseUrl: this.state.serverUrl.replace(/\/$/, "")
          };
          const accessToken = this.getState("tokenResponse.access_token");
          if (accessToken) {
            options.auth = {
              token: accessToken
            };
          } else {
            const {
              username,
              password
            } = this.state;
            if (username && password) {
              options.auth = {
                user: username,
                pass: password
              };
            }
          }
          this.api = fhirJs(options);
          const patientId = this.getState("tokenResponse.patient");
          if (patientId) {
            this.patient.api = fhirJs(Object.assign(Object.assign({}, options), {
              patient: patientId
            }));
          }
        }
        return this;
      }
      /**
       * Returns the ID of the selected patient or null. You should have requested
       * "launch/patient" scope. Otherwise this will return null.
       */
      getPatientId() {
        const tokenResponse = this.state.tokenResponse;
        if (tokenResponse) {
          if (!tokenResponse.patient) {
            if (!(this.state.scope || "").match(/\blaunch(\/patient)?\b/)) {
              debug(strings_1.default.noScopeForId, "patient", "patient");
            } else {
              debug("The ID of the selected patient is not available. Please check if your server supports that.");
            }
            return null;
          }
          return tokenResponse.patient;
        }
        if (this.state.authorizeUri) {
          debug(strings_1.default.noIfNoAuth, "the ID of the selected patient");
        } else {
          debug(strings_1.default.noFreeContext, "selected patient");
        }
        return null;
      }
      /**
       * Returns the ID of the selected encounter or null. You should have
       * requested "launch/encounter" scope. Otherwise this will return null.
       * Note that not all servers support the "launch/encounter" scope so this
       * will be null if they don't.
       */
      getEncounterId() {
        const tokenResponse = this.state.tokenResponse;
        if (tokenResponse) {
          if (!tokenResponse.encounter) {
            if (!(this.state.scope || "").match(/\blaunch(\/encounter)?\b/)) {
              debug(strings_1.default.noScopeForId, "encounter", "encounter");
            } else {
              debug("The ID of the selected encounter is not available. Please check if your server supports that, and that the selected patient has any recorded encounters.");
            }
            return null;
          }
          return tokenResponse.encounter;
        }
        if (this.state.authorizeUri) {
          debug(strings_1.default.noIfNoAuth, "the ID of the selected encounter");
        } else {
          debug(strings_1.default.noFreeContext, "selected encounter");
        }
        return null;
      }
      /**
       * Returns the (decoded) id_token if any. You need to request "openid" and
       * "profile" scopes if you need to receive an id_token (if you need to know
       * who the logged-in user is).
       */
      getIdToken() {
        const tokenResponse = this.state.tokenResponse;
        if (tokenResponse) {
          const idToken = tokenResponse.id_token;
          const scope = this.state.scope || "";
          if (!idToken) {
            const hasOpenid = scope.match(/\bopenid\b/);
            const hasProfile = scope.match(/\bprofile\b/);
            const hasFhirUser = scope.match(/\bfhirUser\b/);
            if (!hasOpenid || !(hasFhirUser || hasProfile)) {
              debug("You are trying to get the id_token but you are not using the right scopes. Please add 'openid' and 'fhirUser' or 'profile' to the scopes you are requesting.");
            } else {
              debug("The id_token is not available. Please check if your server supports that.");
            }
            return null;
          }
          return (0, lib_1.jwtDecode)(idToken, this.environment);
        }
        if (this.state.authorizeUri) {
          debug(strings_1.default.noIfNoAuth, "the id_token");
        } else {
          debug(strings_1.default.noFreeContext, "id_token");
        }
        return null;
      }
      /**
       * Returns the profile of the logged_in user (if any). This is a string
       * having the following shape `"{user type}/{user id}"`. For example:
       * `"Practitioner/abc"` or `"Patient/xyz"`.
       */
      getFhirUser() {
        const idToken = this.getIdToken();
        if (idToken) {
          if (idToken.fhirUser) {
            return idToken.fhirUser.split("/").slice(-2).join("/");
          }
          return idToken.profile;
        }
        return null;
      }
      /**
       * Returns the user ID or null.
       */
      getUserId() {
        const profile = this.getFhirUser();
        if (profile) {
          return profile.split("/")[1];
        }
        return null;
      }
      /**
       * Returns the type of the logged-in user or null. The result can be
       * "Practitioner", "Patient" or "RelatedPerson".
       */
      getUserType() {
        const profile = this.getFhirUser();
        if (profile) {
          return profile.split("/")[0];
        }
        return null;
      }
      /**
       * Builds and returns the value of the `Authorization` header that can be
       * sent to the FHIR server
       */
      getAuthorizationHeader() {
        const accessToken = this.getState("tokenResponse.access_token");
        if (accessToken) {
          return "Bearer " + accessToken;
        }
        const {
          username,
          password
        } = this.state;
        if (username && password) {
          return "Basic " + this.environment.btoa(username + ":" + password);
        }
        return null;
      }
      /**
       * Used internally to clear the state of the instance and the state in the
       * associated storage.
       */
      async _clearState() {
        const storage = this.environment.getStorage();
        const key = await storage.get(settings_1.SMART_KEY);
        if (key) {
          await storage.unset(key);
        }
        await storage.unset(settings_1.SMART_KEY);
        this.state.tokenResponse = {};
      }
      /**
       * @param requestOptions Can be a string URL (relative to the serviceUrl),
       * or an object which will be passed to fetch()
       * @param fhirOptions Additional options to control the behavior
       * @param _resolvedRefs DO NOT USE! Used internally.
       * @category Request
       */
      async request(requestOptions, fhirOptions = {}, _resolvedRefs = {}) {
        var _a;
        const debugRequest = lib_1.debug.extend("client:request");
        (0, lib_1.assert)(requestOptions, "request requires an url or request options as argument");
        let url;
        if (typeof requestOptions == "string" || requestOptions instanceof URL) {
          url = String(requestOptions);
          requestOptions = {};
        } else {
          url = String(requestOptions.url);
        }
        url = (0, lib_1.absolute)(url, this.state.serverUrl);
        const options = {
          graph: fhirOptions.graph !== false,
          flat: !!fhirOptions.flat,
          pageLimit: (_a = fhirOptions.pageLimit) !== null && _a !== void 0 ? _a : 1,
          resolveReferences: (0, lib_1.makeArray)(fhirOptions.resolveReferences || []),
          useRefreshToken: fhirOptions.useRefreshToken !== false,
          onPage: typeof fhirOptions.onPage == "function" ? fhirOptions.onPage : void 0
        };
        const signal = requestOptions.signal || void 0;
        if (options.useRefreshToken) {
          await this.refreshIfNeeded({
            signal
          });
        }
        const authHeader = this.getAuthorizationHeader();
        if (authHeader) {
          requestOptions.headers = Object.assign(Object.assign({}, requestOptions.headers), {
            authorization: authHeader
          });
        }
        debugRequest("%s, options: %O, fhirOptions: %O", url, requestOptions, options);
        let response;
        return super.fhirRequest(url, requestOptions).then((result) => {
          if (requestOptions.includeResponse) {
            response = result.response;
            return result.body;
          }
          return result;
        }).catch(async (error) => {
          if (error.status == 401) {
            if (!this.getState("tokenResponse.access_token")) {
              error.message += "\nThis app cannot be accessed directly. Please launch it as SMART app!";
              throw error;
            }
            if (!options.useRefreshToken) {
              debugRequest("Your session has expired and the useRefreshToken option is set to false. Please re-launch the app.");
              await this._clearState();
              error.message += "\n" + strings_1.default.expired;
              throw error;
            }
            debugRequest("Auto-refresh failed! Please re-launch the app.");
            await this._clearState();
            error.message += "\n" + strings_1.default.expired;
            throw error;
          }
          throw error;
        }).catch((error) => {
          if (error.status == 403) {
            debugRequest("Permission denied! Please make sure that you have requested the proper scopes.");
          }
          throw error;
        }).then(async (data) => {
          if (!data || typeof data == "string" || data instanceof Response) {
            if (requestOptions.includeResponse) {
              return {
                body: data,
                response
              };
            }
            return data;
          }
          await this.fetchReferences(data, options.resolveReferences, options.graph, _resolvedRefs, requestOptions);
          return Promise.resolve(data).then(async (_data) => {
            if (_data && _data.resourceType == "Bundle") {
              const links = _data.link || [];
              if (options.flat) {
                _data = (_data.entry || []).map((entry) => entry.resource);
              }
              if (options.onPage) {
                await options.onPage(_data, Object.assign({}, _resolvedRefs));
              }
              if (--options.pageLimit) {
                const next = links.find((l) => l.relation == "next");
                _data = (0, lib_1.makeArray)(_data);
                if (next && next.url) {
                  const nextPage = await this.request({
                    url: next.url,
                    // Aborting the main request (even after it is complete)
                    // must propagate to any child requests and abort them!
                    // To do so, just pass the same AbortSignal if one is
                    // provided.
                    signal
                  }, options, _resolvedRefs);
                  if (options.onPage) {
                    return null;
                  }
                  if (options.resolveReferences.length) {
                    Object.assign(_resolvedRefs, nextPage.references);
                    return _data.concat((0, lib_1.makeArray)(nextPage.data || nextPage));
                  }
                  return _data.concat((0, lib_1.makeArray)(nextPage));
                }
              }
            }
            return _data;
          }).then((_data) => {
            if (options.graph) {
              _resolvedRefs = {};
            } else if (!options.onPage && options.resolveReferences.length) {
              return {
                data: _data,
                references: _resolvedRefs
              };
            }
            return _data;
          }).then((_data) => {
            if (requestOptions.includeResponse) {
              return {
                body: _data,
                response
              };
            }
            return _data;
          });
        });
      }
      /**
       * Checks if access token and refresh token are present. If they are, and if
       * the access token is expired or is about to expire in the next 10 seconds,
       * calls `this.refresh()` to obtain new access token.
       * @param requestOptions Any options to pass to the fetch call. Most of them
       * will be overridden, bit it might still be useful for passing additional
       * request options or an abort signal.
       * @category Request
       */
      refreshIfNeeded(requestOptions = {}) {
        const accessToken = this.getState("tokenResponse.access_token");
        const refreshToken = this.getState("tokenResponse.refresh_token");
        const expiresAt = this.state.expiresAt || 0;
        if (accessToken && refreshToken && expiresAt - 10 < Date.now() / 1e3) {
          return this.refresh(requestOptions);
        }
        return Promise.resolve(this.state);
      }
      /**
       * Use the refresh token to obtain new access token. If the refresh token is
       * expired (or this fails for any other reason) it will be deleted from the
       * state, so that we don't enter into loops trying to re-authorize.
       *
       * This method is typically called internally from [[request]] if
       * certain request fails with 401.
       *
       * @param requestOptions Any options to pass to the fetch call. Most of them
       * will be overridden, bit it might still be useful for passing additional
       * request options or an abort signal.
       * @category Request
       */
      refresh(requestOptions = {}) {
        var _a, _b;
        const debugRefresh = lib_1.debug.extend("client:refresh");
        debugRefresh("Attempting to refresh with refresh_token...");
        const refreshToken = (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.tokenResponse) === null || _b === void 0 ? void 0 : _b.refresh_token;
        (0, lib_1.assert)(refreshToken, "Unable to refresh. No refresh_token found.");
        const tokenUri = this.state.tokenUri;
        (0, lib_1.assert)(tokenUri, "Unable to refresh. No tokenUri found.");
        const scopes = this.getState("tokenResponse.scope") || "";
        const hasOfflineAccess = scopes.search(/\boffline_access\b/) > -1;
        const hasOnlineAccess = scopes.search(/\bonline_access\b/) > -1;
        (0, lib_1.assert)(hasOfflineAccess || hasOnlineAccess, "Unable to refresh. No offline_access or online_access scope found.");
        if (!this._refreshTask) {
          let body = `grant_type=refresh_token&refresh_token=${encodeURIComponent(refreshToken)}`;
          if (this.environment.options.refreshTokenWithClientId) {
            body += `&client_id=${this.state.clientId}`;
          }
          const refreshRequestOptions = Object.assign(Object.assign({
            credentials: this.environment.options.refreshTokenWithCredentials || "same-origin"
          }, requestOptions), {
            method: "POST",
            mode: "cors",
            headers: Object.assign(Object.assign({}, requestOptions.headers || {}), {
              "content-type": "application/x-www-form-urlencoded"
            }),
            body
          });
          if (!("authorization" in refreshRequestOptions.headers)) {
            const {
              clientSecret,
              clientId
            } = this.state;
            if (clientSecret) {
              refreshRequestOptions.headers.authorization = "Basic " + this.environment.btoa(clientId + ":" + clientSecret);
            }
          }
          this._refreshTask = (0, lib_1.request)(tokenUri, refreshRequestOptions).then((data) => {
            (0, lib_1.assert)(data.access_token, "No access token received");
            debugRefresh("Received new access token response %O", data);
            this.state.tokenResponse = Object.assign(Object.assign({}, this.state.tokenResponse), data);
            this.state.expiresAt = (0, lib_1.getAccessTokenExpiration)(data, this.environment);
            return this.state;
          }).catch((error) => {
            var _a2, _b2;
            if ((_b2 = (_a2 = this.state) === null || _a2 === void 0 ? void 0 : _a2.tokenResponse) === null || _b2 === void 0 ? void 0 : _b2.refresh_token) {
              debugRefresh("Deleting the expired or invalid refresh token.");
              delete this.state.tokenResponse.refresh_token;
            }
            throw error;
          }).finally(() => {
            this._refreshTask = null;
            const key = this.state.key;
            if (key) {
              this.environment.getStorage().set(key, this.state);
            } else {
              debugRefresh("No 'key' found in Clint.state. Cannot persist the instance.");
            }
          });
        }
        return this._refreshTask;
      }
      // utils -------------------------------------------------------------------
      /**
       * Groups the observations by code. Returns a map that will look like:
       * ```js
       * const map = client.byCodes(observations, "code");
       * // map = {
       * //     "55284-4": [ observation1, observation2 ],
       * //     "6082-2": [ observation3 ]
       * // }
       * ```
       * @param observations Array of observations
       * @param property The name of a CodeableConcept property to group by
       * @todo This should be deprecated and moved elsewhere. One should not have
       * to obtain an instance of [[Client]] just to use utility functions like this.
       * @deprecated
       * @category Utility
       */
      byCode(observations, property) {
        return (0, lib_1.byCode)(observations, property);
      }
      /**
       * First groups the observations by code using `byCode`. Then returns a function
       * that accepts codes as arguments and will return a flat array of observations
       * having that codes. Example:
       * ```js
       * const filter = client.byCodes(observations, "category");
       * filter("laboratory") // => [ observation1, observation2 ]
       * filter("vital-signs") // => [ observation3 ]
       * filter("laboratory", "vital-signs") // => [ observation1, observation2, observation3 ]
       * ```
       * @param observations Array of observations
       * @param property The name of a CodeableConcept property to group by
       * @todo This should be deprecated and moved elsewhere. One should not have
       * to obtain an instance of [[Client]] just to use utility functions like this.
       * @deprecated
       * @category Utility
       */
      byCodes(observations, property) {
        return (0, lib_1.byCodes)(observations, property);
      }
      /**
       * Walks through an object (or array) and returns the value found at the
       * provided path. This function is very simple so it intentionally does not
       * support any argument polymorphism, meaning that the path can only be a
       * dot-separated string. If the path is invalid returns undefined.
       * @param obj The object (or Array) to walk through
       * @param path The path (eg. "a.b.4.c")
       * @returns {*} Whatever is found in the path or undefined
       * @todo This should be deprecated and moved elsewhere. One should not have
       * to obtain an instance of [[Client]] just to use utility functions like this.
       * @deprecated
       * @category Utility
       */
      getPath(obj, path = "") {
        return (0, lib_1.getPath)(obj, path);
      }
      /**
       * Returns a copy of the client state. Accepts a dot-separated path argument
       * (same as for `getPath`) to allow for selecting specific properties.
       * Examples:
       * ```js
       * client.getState(); // -> the entire state object
       * client.getState("serverUrl"); // -> the URL we are connected to
       * client.getState("tokenResponse.patient"); // -> The selected patient ID (if any)
       * ```
       * @param path The path (eg. "a.b.4.c")
       * @returns {*} Whatever is found in the path or undefined
       */
      getState(path = "") {
        return (0, lib_1.getPath)(Object.assign({}, this.state), path);
      }
    };
    exports.default = Client;
  }
});

// node_modules/fhirclient/lib/smart.js
var require_smart = __commonJS({
  "node_modules/fhirclient/lib/smart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.init = exports.buildTokenRequest = exports.ready = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;
    var lib_1 = require_lib();
    var Client_1 = require_Client();
    var settings_1 = require_settings();
    Object.defineProperty(exports, "KEY", {
      enumerable: true,
      get: function() {
        return settings_1.SMART_KEY;
      }
    });
    var debug = lib_1.debug.extend("oauth2");
    function isBrowser() {
      return typeof window === "object";
    }
    function fetchWellKnownJson(baseUrl = "/", requestOptions) {
      const url = String(baseUrl).replace(/\/*$/, "/") + ".well-known/smart-configuration";
      return (0, lib_1.getAndCache)(url, requestOptions).catch((ex) => {
        throw new Error(`Failed to fetch the well-known json "${url}". ${ex.message}`);
      });
    }
    exports.fetchWellKnownJson = fetchWellKnownJson;
    function getSecurityExtensionsFromWellKnownJson(baseUrl = "/", requestOptions) {
      return fetchWellKnownJson(baseUrl, requestOptions).then((meta) => {
        if (!meta.authorization_endpoint || !meta.token_endpoint) {
          throw new Error("Invalid wellKnownJson");
        }
        return {
          registrationUri: meta.registration_endpoint || "",
          authorizeUri: meta.authorization_endpoint,
          tokenUri: meta.token_endpoint,
          codeChallengeMethods: meta.code_challenge_methods_supported || []
        };
      });
    }
    function getSecurityExtensionsFromConformanceStatement(baseUrl = "/", requestOptions) {
      return (0, lib_1.fetchConformanceStatement)(baseUrl, requestOptions).then((meta) => {
        const nsUri = "http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris";
        const extensions = ((0, lib_1.getPath)(meta || {}, "rest.0.security.extension") || []).filter((e) => e.url === nsUri).map((o) => o.extension)[0];
        const out = {
          registrationUri: "",
          authorizeUri: "",
          tokenUri: "",
          codeChallengeMethods: []
        };
        if (extensions) {
          extensions.forEach((ext) => {
            if (ext.url === "register") {
              out.registrationUri = ext.valueUri;
            }
            if (ext.url === "authorize") {
              out.authorizeUri = ext.valueUri;
            }
            if (ext.url === "token") {
              out.tokenUri = ext.valueUri;
            }
          });
        }
        return out;
      });
    }
    function getSecurityExtensions(baseUrl = "/") {
      return getSecurityExtensionsFromWellKnownJson(baseUrl).catch(() => getSecurityExtensionsFromConformanceStatement(baseUrl));
    }
    exports.getSecurityExtensions = getSecurityExtensions;
    async function authorize(env, params = {}) {
      const url = env.getUrl();
      if (Array.isArray(params)) {
        const urlISS = url.searchParams.get("iss") || url.searchParams.get("fhirServiceUrl");
        if (!urlISS) {
          throw new Error('Passing in an "iss" url parameter is required if authorize uses multiple configurations');
        }
        const cfg = params.find((x) => {
          if (x.issMatch) {
            if (typeof x.issMatch === "function") {
              return !!x.issMatch(urlISS);
            }
            if (typeof x.issMatch === "string") {
              return x.issMatch === urlISS;
            }
            if (x.issMatch instanceof RegExp) {
              return x.issMatch.test(urlISS);
            }
          }
          return false;
        });
        (0, lib_1.assert)(cfg, `No configuration found matching the current "iss" parameter "${urlISS}"`);
        return await authorize(env, cfg);
      }
      const {
        clientSecret,
        fakeTokenResponse,
        encounterId,
        target,
        width,
        height,
        pkceMode,
        clientPublicKeySetUrl,
        // Two deprecated values to use as fall-back values later
        redirect_uri,
        client_id
      } = params;
      let {
        iss,
        launch,
        patientId,
        fhirServiceUrl,
        redirectUri,
        noRedirect,
        scope = "",
        clientId,
        completeInTarget,
        clientPrivateJwk,
        stateKey
      } = params;
      const storage = env.getStorage();
      iss = url.searchParams.get("iss") || iss;
      fhirServiceUrl = url.searchParams.get("fhirServiceUrl") || fhirServiceUrl;
      launch = url.searchParams.get("launch") || launch;
      patientId = url.searchParams.get("patientId") || patientId;
      clientId = url.searchParams.get("clientId") || clientId;
      if (!clientId) {
        clientId = client_id;
      }
      if (!redirectUri) {
        redirectUri = redirect_uri;
      }
      if (!redirectUri) {
        redirectUri = env.relative(".");
      } else if (!redirectUri.match(/^https?\:\/\//)) {
        redirectUri = env.relative(redirectUri);
      }
      const serverUrl = String(iss || fhirServiceUrl || "");
      if (!serverUrl) {
        throw new Error("No server url found. It must be specified as `iss` or as `fhirServiceUrl` parameter");
      }
      if (iss) {
        debug("Making %s launch...", launch ? "EHR" : "standalone");
      }
      if (launch && !scope.match(/launch/)) {
        scope += " launch";
      }
      if (isBrowser()) {
        const inFrame = isInFrame();
        const inPopUp = isInPopUp();
        if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {
          completeInTarget = inFrame;
          console.warn('Your app is being authorized from within an iframe or popup window. Please be explicit and provide a "completeInTarget" option. Use "true" to complete the authorization in the same window, or "false" to try to complete it in the parent or the opener window. See http://docs.smarthealthit.org/client-js/api.html');
        }
      }
      const oldKey = await storage.get(settings_1.SMART_KEY);
      await storage.unset(oldKey);
      stateKey = stateKey !== null && stateKey !== void 0 ? stateKey : (0, lib_1.randomString)(16);
      const state = {
        clientId,
        scope,
        redirectUri,
        serverUrl,
        clientSecret,
        clientPrivateJwk,
        tokenResponse: {},
        key: stateKey,
        completeInTarget,
        clientPublicKeySetUrl
      };
      const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, "options.fullSessionStorageSupport") : true;
      if (fullSessionStorageSupport) {
        await storage.set(settings_1.SMART_KEY, stateKey);
      }
      if (fakeTokenResponse) {
        Object.assign(state.tokenResponse, fakeTokenResponse);
      }
      if (patientId) {
        Object.assign(state.tokenResponse, {
          patient: patientId
        });
      }
      if (encounterId) {
        Object.assign(state.tokenResponse, {
          encounter: encounterId
        });
      }
      let redirectUrl = redirectUri + "?state=" + encodeURIComponent(stateKey);
      if (fhirServiceUrl && !iss) {
        debug("Making fake launch...");
        await storage.set(stateKey, state);
        if (noRedirect) {
          return redirectUrl;
        }
        return await env.redirect(redirectUrl);
      }
      const extensions = await getSecurityExtensions(serverUrl);
      Object.assign(state, extensions);
      await storage.set(stateKey, state);
      if (!state.authorizeUri) {
        if (noRedirect) {
          return redirectUrl;
        }
        return await env.redirect(redirectUrl);
      }
      const redirectParams = ["response_type=code", "client_id=" + encodeURIComponent(clientId || ""), "scope=" + encodeURIComponent(scope), "redirect_uri=" + encodeURIComponent(redirectUri), "aud=" + encodeURIComponent(serverUrl), "state=" + encodeURIComponent(stateKey)];
      if (launch) {
        redirectParams.push("launch=" + encodeURIComponent(launch));
      }
      if (shouldIncludeChallenge(extensions.codeChallengeMethods.includes("S256"), pkceMode)) {
        let codes = await env.security.generatePKCEChallenge();
        Object.assign(state, codes);
        await storage.set(stateKey, state);
        redirectParams.push("code_challenge=" + state.codeChallenge);
        redirectParams.push("code_challenge_method=S256");
      }
      redirectUrl = state.authorizeUri + "?" + redirectParams.join("&");
      if (noRedirect) {
        return redirectUrl;
      }
      if (target && isBrowser()) {
        let win;
        win = await (0, lib_1.getTargetWindow)(target, width, height);
        if (win !== self) {
          try {
            win.sessionStorage.removeItem(oldKey);
            win.sessionStorage.setItem(stateKey, JSON.stringify(state));
          } catch (ex) {
            (0, lib_1.debug)(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to "_self". %s`, ex);
            win = self;
          }
        }
        if (win !== self) {
          try {
            win.location.href = redirectUrl;
            self.addEventListener("message", onMessage);
          } catch (ex) {
            (0, lib_1.debug)(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to "_self". %s`, ex);
            self.location.href = redirectUrl;
          }
        } else {
          self.location.href = redirectUrl;
        }
        return;
      } else {
        return await env.redirect(redirectUrl);
      }
    }
    exports.authorize = authorize;
    function shouldIncludeChallenge(S256supported, pkceMode) {
      if (pkceMode === "disabled") {
        return false;
      }
      if (pkceMode === "unsafeV1") {
        return true;
      }
      if (pkceMode === "required") {
        if (!S256supported) {
          throw new Error("Required PKCE code challenge method (`S256`) was not found in the server's codeChallengeMethods declaration.");
        }
        return true;
      }
      return S256supported;
    }
    function isInFrame() {
      try {
        return self !== top && parent !== self;
      } catch (e) {
        return true;
      }
    }
    exports.isInFrame = isInFrame;
    function isInPopUp() {
      try {
        return self === top && !!opener && opener !== self && !!window.name;
      } catch (e) {
        return false;
      }
    }
    exports.isInPopUp = isInPopUp;
    function onMessage(e) {
      if (e.data.type == "completeAuth" && e.origin === new URL(self.location.href).origin) {
        window.removeEventListener("message", onMessage);
        window.location.href = e.data.url;
      }
    }
    exports.onMessage = onMessage;
    async function ready(env, options = {}) {
      var _a, _b;
      const url = env.getUrl();
      const Storage = env.getStorage();
      const params = url.searchParams;
      let key = params.get("state") || options.stateKey;
      const code = params.get("code") || options.code;
      const authError = params.get("error");
      const authErrorDescription = params.get("error_description");
      if (!key) {
        key = await Storage.get(settings_1.SMART_KEY);
      }
      if (authError || authErrorDescription) {
        throw new Error([authError, authErrorDescription].filter(Boolean).join(": "));
      }
      debug("key: %s, code: %s", key, code);
      (0, lib_1.assert)(key, "No 'state' parameter found. Please (re)launch the app.");
      let state = await Storage.get(key);
      const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, "options.fullSessionStorageSupport") : true;
      if (isBrowser() && state && !state.completeInTarget) {
        const inFrame = isInFrame();
        const inPopUp = isInPopUp();
        if ((inFrame || inPopUp) && !url.searchParams.get("complete")) {
          url.searchParams.set("complete", "1");
          const {
            href,
            origin
          } = url;
          if (inFrame) {
            parent.postMessage({
              type: "completeAuth",
              url: href
            }, origin);
          }
          if (inPopUp) {
            opener.postMessage({
              type: "completeAuth",
              url: href
            }, origin);
            window.close();
          }
          return new Promise(() => {
          });
        }
      }
      url.searchParams.delete("complete");
      const hasState = params.has("state") || options.stateKey ? true : false;
      if (isBrowser() && (0, lib_1.getPath)(env, "options.replaceBrowserHistory") && (code || hasState)) {
        if (code) {
          params.delete("code");
          debug("Removed code parameter from the url.");
        }
        if (hasState && fullSessionStorageSupport) {
          params.delete("state");
          debug("Removed state parameter from the url.");
        }
        if (window.history.replaceState) {
          window.history.replaceState({}, "", url.href);
        }
      }
      (0, lib_1.assert)(state, "No state found! Please (re)launch the app.");
      const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token);
      if (!authorized && state.tokenUri) {
        (0, lib_1.assert)(code, "'code' url parameter is required");
        debug("Preparing to exchange the code for access token...");
        const requestOptions = await buildTokenRequest(env, {
          code,
          state,
          clientPublicKeySetUrl: options.clientPublicKeySetUrl,
          privateKey: options.privateKey || state.clientPrivateJwk
        });
        debug("Token request options: %O", requestOptions);
        const tokenResponse = await (0, lib_1.request)(state.tokenUri, requestOptions);
        debug("Token response: %O", tokenResponse);
        (0, lib_1.assert)(tokenResponse.access_token, "Failed to obtain access token.");
        state.expiresAt = (0, lib_1.getAccessTokenExpiration)(tokenResponse, env);
        state = Object.assign(Object.assign({}, state), {
          tokenResponse
        });
        await Storage.set(key, state);
        debug("Authorization successful!");
      } else {
        debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? "Already authorized" : "No authorization needed");
      }
      if (fullSessionStorageSupport) {
        await Storage.set(settings_1.SMART_KEY, key);
      }
      const client = new Client_1.default(env, state);
      debug("Created client instance: %O", client);
      return client;
    }
    exports.ready = ready;
    async function buildTokenRequest(env, {
      code,
      state,
      clientPublicKeySetUrl,
      privateKey
    }) {
      const {
        redirectUri,
        clientSecret,
        tokenUri,
        clientId,
        codeVerifier
      } = state;
      (0, lib_1.assert)(redirectUri, "Missing state.redirectUri");
      (0, lib_1.assert)(tokenUri, "Missing state.tokenUri");
      (0, lib_1.assert)(clientId, "Missing state.clientId");
      const requestOptions = {
        method: "POST",
        headers: {
          "content-type": "application/x-www-form-urlencoded"
        },
        body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`
      };
      if (clientSecret) {
        requestOptions.headers.authorization = "Basic " + env.btoa(clientId + ":" + clientSecret);
        debug("Using state.clientSecret to construct the authorization header: %s", requestOptions.headers.authorization);
      } else if (privateKey) {
        const pk = "key" in privateKey ? privateKey.key : await env.security.importJWK(privateKey);
        const jwtHeaders = {
          typ: "JWT",
          kid: privateKey.kid,
          jku: clientPublicKeySetUrl || state.clientPublicKeySetUrl
        };
        const jwtClaims = {
          iss: clientId,
          sub: clientId,
          aud: tokenUri,
          jti: env.base64urlencode(env.security.randomBytes(32)),
          exp: (0, lib_1.getTimeInFuture)(120)
          // two minutes in the future
        };
        const clientAssertion = await env.security.signCompactJws(privateKey.alg, pk, jwtHeaders, jwtClaims);
        requestOptions.body += `&client_assertion_type=${encodeURIComponent("urn:ietf:params:oauth:client-assertion-type:jwt-bearer")}`;
        requestOptions.body += `&client_assertion=${encodeURIComponent(clientAssertion)}`;
        debug("Using state.clientPrivateJwk to add a client_assertion to the POST body");
      } else {
        debug("Public client detected; adding state.clientId to the POST body");
        requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;
      }
      if (codeVerifier) {
        debug("Found state.codeVerifier, adding to the POST body");
        requestOptions.body += "&code_verifier=" + codeVerifier;
      }
      return requestOptions;
    }
    exports.buildTokenRequest = buildTokenRequest;
    async function init(env, authorizeOptions, readyOptions) {
      const url = env.getUrl();
      const code = url.searchParams.get("code");
      const state = url.searchParams.get("state");
      if (code && state) {
        return ready(env, readyOptions);
      }
      const storage = env.getStorage();
      const key = state || await storage.get(settings_1.SMART_KEY);
      const cached = await storage.get(key);
      if (cached) {
        return new Client_1.default(env, cached);
      }
      return authorize(env, authorizeOptions).then(() => {
        return new Promise(() => {
        });
      });
    }
    exports.init = init;
  }
});

// node_modules/fhirclient/lib/storage/BrowserStorage.js
var require_BrowserStorage = __commonJS({
  "node_modules/fhirclient/lib/storage/BrowserStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var Storage = class {
      /**
       * Gets the value at `key`. Returns a promise that will be resolved
       * with that value (or undefined for missing keys).
       */
      async get(key) {
        const value = sessionStorage[key];
        if (value) {
          return JSON.parse(value);
        }
        return null;
      }
      /**
       * Sets the `value` on `key` and returns a promise that will be resolved
       * with the value that was set.
       */
      async set(key, value) {
        sessionStorage[key] = JSON.stringify(value);
        return value;
      }
      /**
       * Deletes the value at `key`. Returns a promise that will be resolved
       * with true if the key was deleted or with false if it was not (eg. if
       * did not exist).
       */
      async unset(key) {
        if (key in sessionStorage) {
          delete sessionStorage[key];
          return true;
        }
        return false;
      }
    };
    exports.default = Storage;
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.8";
      var VERSION = version;
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i) {
          return tab[c] = i;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = typeof btoa === "function" ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI = function(src) {
        return encode(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, r1, r2;
        var binArray = [];
        for (var i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          if (r1 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255));
          } else if (r2 === 64) {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255));
          } else {
            binArray.push(_fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255));
          }
        }
        return binArray.join("");
      };
      var _atob = typeof atob === "function" ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a).split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string")
          return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/isomorphic-webcrypto/src/webcrypto-shim.mjs
var init_webcrypto_shim = __esm({
  "node_modules/isomorphic-webcrypto/src/webcrypto-shim.mjs"() {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return factory(global2);
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory(global2);
      } else {
        factory(global2);
      }
    })(typeof self !== "undefined" ? self : void 0, function(global2) {
      "use strict";
      if (typeof Promise !== "function")
        throw "Promise support required";
      var _crypto = global2.crypto || global2.msCrypto;
      if (!_crypto) return;
      var _subtle = _crypto.subtle || _crypto.webkitSubtle;
      if (!_subtle) return;
      var _Crypto = global2.Crypto || _crypto.constructor || Object, _SubtleCrypto = global2.SubtleCrypto || _subtle.constructor || Object, _CryptoKey = global2.CryptoKey || global2.Key || Object;
      var isEdge = global2.navigator.userAgent.indexOf("Edge/") > -1;
      var isIE = !!global2.msCrypto && !isEdge;
      var isWebkit = !_crypto.subtle && !!_crypto.webkitSubtle;
      if (!isIE && !isWebkit) return;
      function s2a(s) {
        return btoa(s).replace(/\=+$/, "").replace(/\+/g, "-").replace(/\//g, "_");
      }
      function a2s(s) {
        s += "===", s = s.slice(0, -s.length % 4);
        return atob(s.replace(/-/g, "+").replace(/_/g, "/"));
      }
      function s2b(s) {
        var b = new Uint8Array(s.length);
        for (var i = 0; i < s.length; i++) b[i] = s.charCodeAt(i);
        return b;
      }
      function b2s(b) {
        if (b instanceof ArrayBuffer) b = new Uint8Array(b);
        return String.fromCharCode.apply(String, b);
      }
      function alg(a) {
        var r = { "name": (a.name || a || "").toUpperCase().replace("V", "v") };
        switch (r.name) {
          case "SHA-1":
          case "SHA-256":
          case "SHA-384":
          case "SHA-512":
            break;
          case "AES-CBC":
          case "AES-GCM":
          case "AES-KW":
            if (a.length) r["length"] = a.length;
            break;
          case "HMAC":
            if (a.hash) r["hash"] = alg(a.hash);
            if (a.length) r["length"] = a.length;
            break;
          case "RSAES-PKCS1-v1_5":
            if (a.publicExponent) r["publicExponent"] = new Uint8Array(a.publicExponent);
            if (a.modulusLength) r["modulusLength"] = a.modulusLength;
            break;
          case "RSASSA-PKCS1-v1_5":
          case "RSA-OAEP":
            if (a.hash) r["hash"] = alg(a.hash);
            if (a.publicExponent) r["publicExponent"] = new Uint8Array(a.publicExponent);
            if (a.modulusLength) r["modulusLength"] = a.modulusLength;
            break;
          default:
            throw new SyntaxError("Bad algorithm name");
        }
        return r;
      }
      ;
      function jwkAlg(a) {
        return {
          "HMAC": {
            "SHA-1": "HS1",
            "SHA-256": "HS256",
            "SHA-384": "HS384",
            "SHA-512": "HS512"
          },
          "RSASSA-PKCS1-v1_5": {
            "SHA-1": "RS1",
            "SHA-256": "RS256",
            "SHA-384": "RS384",
            "SHA-512": "RS512"
          },
          "RSAES-PKCS1-v1_5": {
            "": "RSA1_5"
          },
          "RSA-OAEP": {
            "SHA-1": "RSA-OAEP",
            "SHA-256": "RSA-OAEP-256"
          },
          "AES-KW": {
            "128": "A128KW",
            "192": "A192KW",
            "256": "A256KW"
          },
          "AES-GCM": {
            "128": "A128GCM",
            "192": "A192GCM",
            "256": "A256GCM"
          },
          "AES-CBC": {
            "128": "A128CBC",
            "192": "A192CBC",
            "256": "A256CBC"
          }
        }[a.name][(a.hash || {}).name || a.length || ""];
      }
      function b2jwk(k) {
        if (k instanceof ArrayBuffer || k instanceof Uint8Array) k = JSON.parse(decodeURIComponent(escape(b2s(k))));
        var jwk = { "kty": k.kty, "alg": k.alg, "ext": k.ext || k.extractable };
        switch (jwk.kty) {
          case "oct":
            jwk.k = k.k;
          case "RSA":
            ["n", "e", "d", "p", "q", "dp", "dq", "qi", "oth"].forEach(function(x) {
              if (x in k) jwk[x] = k[x];
            });
            break;
          default:
            throw new TypeError("Unsupported key type");
        }
        return jwk;
      }
      function jwk2b(k) {
        var jwk = b2jwk(k);
        if (isIE) jwk["extractable"] = jwk.ext, delete jwk.ext;
        return s2b(unescape(encodeURIComponent(JSON.stringify(jwk)))).buffer;
      }
      function pkcs2jwk(k) {
        var info = b2der(k), prv = false;
        if (info.length > 2) prv = true, info.shift();
        var jwk = { "ext": true };
        switch (info[0][0]) {
          case "1.2.840.113549.1.1.1":
            var rsaComp = ["n", "e", "d", "p", "q", "dp", "dq", "qi"], rsaKey = b2der(info[1]);
            if (prv) rsaKey.shift();
            for (var i = 0; i < rsaKey.length; i++) {
              if (!rsaKey[i][0]) rsaKey[i] = rsaKey[i].subarray(1);
              jwk[rsaComp[i]] = s2a(b2s(rsaKey[i]));
            }
            jwk["kty"] = "RSA";
            break;
          default:
            throw new TypeError("Unsupported key type");
        }
        return jwk;
      }
      function jwk2pkcs(k) {
        var key, info = [["", null]], prv = false;
        switch (k.kty) {
          case "RSA":
            var rsaComp = ["n", "e", "d", "p", "q", "dp", "dq", "qi"], rsaKey = [];
            for (var i = 0; i < rsaComp.length; i++) {
              if (!(rsaComp[i] in k)) break;
              var b = rsaKey[i] = s2b(a2s(k[rsaComp[i]]));
              if (b[0] & 128) rsaKey[i] = new Uint8Array(b.length + 1), rsaKey[i].set(b, 1);
            }
            if (rsaKey.length > 2) prv = true, rsaKey.unshift(new Uint8Array([0]));
            info[0][0] = "1.2.840.113549.1.1.1";
            key = rsaKey;
            break;
          default:
            throw new TypeError("Unsupported key type");
        }
        info.push(new Uint8Array(der2b(key)).buffer);
        if (!prv) info[1] = { "tag": 3, "value": info[1] };
        else info.unshift(new Uint8Array([0]));
        return new Uint8Array(der2b(info)).buffer;
      }
      var oid2str = { "KoZIhvcNAQEB": "1.2.840.113549.1.1.1" }, str2oid = { "1.2.840.113549.1.1.1": "KoZIhvcNAQEB" };
      function b2der(buf, ctx) {
        if (buf instanceof ArrayBuffer) buf = new Uint8Array(buf);
        if (!ctx) ctx = { pos: 0, end: buf.length };
        if (ctx.end - ctx.pos < 2 || ctx.end > buf.length) throw new RangeError("Malformed DER");
        var tag = buf[ctx.pos++], len = buf[ctx.pos++];
        if (len >= 128) {
          len &= 127;
          if (ctx.end - ctx.pos < len) throw new RangeError("Malformed DER");
          for (var xlen = 0; len--; ) xlen <<= 8, xlen |= buf[ctx.pos++];
          len = xlen;
        }
        if (ctx.end - ctx.pos < len) throw new RangeError("Malformed DER");
        var rv;
        switch (tag) {
          case 2:
            rv = buf.subarray(ctx.pos, ctx.pos += len);
            break;
          case 3:
            if (buf[ctx.pos++]) throw new Error("Unsupported bit string");
            len--;
          case 4:
            rv = new Uint8Array(buf.subarray(ctx.pos, ctx.pos += len)).buffer;
            break;
          case 5:
            rv = null;
            break;
          case 6:
            var oid = btoa(b2s(buf.subarray(ctx.pos, ctx.pos += len)));
            if (!(oid in oid2str)) throw new Error("Unsupported OBJECT ID " + oid);
            rv = oid2str[oid];
            break;
          case 48:
            rv = [];
            for (var end = ctx.pos + len; ctx.pos < end; ) rv.push(b2der(buf, ctx));
            break;
          default:
            throw new Error("Unsupported DER tag 0x" + tag.toString(16));
        }
        return rv;
      }
      function der2b(val, buf) {
        if (!buf) buf = [];
        var tag = 0, len = 0, pos = buf.length + 2;
        buf.push(0, 0);
        if (val instanceof Uint8Array) {
          tag = 2, len = val.length;
          for (var i = 0; i < len; i++) buf.push(val[i]);
        } else if (val instanceof ArrayBuffer) {
          tag = 4, len = val.byteLength, val = new Uint8Array(val);
          for (var i = 0; i < len; i++) buf.push(val[i]);
        } else if (val === null) {
          tag = 5, len = 0;
        } else if (typeof val === "string" && val in str2oid) {
          var oid = s2b(atob(str2oid[val]));
          tag = 6, len = oid.length;
          for (var i = 0; i < len; i++) buf.push(oid[i]);
        } else if (val instanceof Array) {
          for (var i = 0; i < val.length; i++) der2b(val[i], buf);
          tag = 48, len = buf.length - pos;
        } else if (typeof val === "object" && val.tag === 3 && val.value instanceof ArrayBuffer) {
          val = new Uint8Array(val.value), tag = 3, len = val.byteLength;
          buf.push(0);
          for (var i = 0; i < len; i++) buf.push(val[i]);
          len++;
        } else {
          throw new Error("Unsupported DER value " + val);
        }
        if (len >= 128) {
          var xlen = len, len = 4;
          buf.splice(pos, 0, xlen >> 24 & 255, xlen >> 16 & 255, xlen >> 8 & 255, xlen & 255);
          while (len > 1 && !(xlen >> 24)) xlen <<= 8, len--;
          if (len < 4) buf.splice(pos, 4 - len);
          len |= 128;
        }
        buf.splice(pos - 2, 2, tag, len);
        return buf;
      }
      function CryptoKey(key, alg2, ext, use) {
        Object.defineProperties(this, {
          _key: {
            value: key
          },
          type: {
            value: key.type,
            enumerable: true
          },
          extractable: {
            value: ext === void 0 ? key.extractable : ext,
            enumerable: true
          },
          algorithm: {
            value: alg2 === void 0 ? key.algorithm : alg2,
            enumerable: true
          },
          usages: {
            value: use === void 0 ? key.usages : use,
            enumerable: true
          }
        });
      }
      function isPubKeyUse(u) {
        return u === "verify" || u === "encrypt" || u === "wrapKey";
      }
      function isPrvKeyUse(u) {
        return u === "sign" || u === "decrypt" || u === "unwrapKey";
      }
      ["generateKey", "importKey", "unwrapKey"].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c) {
          var args = [].slice.call(arguments), ka, kx, ku;
          switch (m) {
            case "generateKey":
              ka = alg(a), kx = b, ku = c;
              break;
            case "importKey":
              ka = alg(c), kx = args[3], ku = args[4];
              if (a === "jwk") {
                b = b2jwk(b);
                if (!b.alg) b.alg = jwkAlg(ka);
                if (!b.key_ops) b.key_ops = b.kty !== "oct" ? "d" in b ? ku.filter(isPrvKeyUse) : ku.filter(isPubKeyUse) : ku.slice();
                args[1] = jwk2b(b);
              }
              break;
            case "unwrapKey":
              ka = args[4], kx = args[5], ku = args[6];
              args[2] = c._key;
              break;
          }
          if (m === "generateKey" && ka.name === "HMAC" && ka.hash) {
            ka.length = ka.length || { "SHA-1": 512, "SHA-256": 512, "SHA-384": 1024, "SHA-512": 1024 }[ka.hash.name];
            return _subtle.importKey("raw", _crypto.getRandomValues(new Uint8Array(ka.length + 7 >> 3)), ka, kx, ku);
          }
          if (isWebkit && m === "generateKey" && ka.name === "RSASSA-PKCS1-v1_5" && (!ka.modulusLength || ka.modulusLength >= 2048)) {
            a = alg(a), a.name = "RSAES-PKCS1-v1_5", delete a.hash;
            return _subtle.generateKey(a, true, ["encrypt", "decrypt"]).then(function(k) {
              return Promise.all([
                _subtle.exportKey("jwk", k.publicKey),
                _subtle.exportKey("jwk", k.privateKey)
              ]);
            }).then(function(keys) {
              keys[0].alg = keys[1].alg = jwkAlg(ka);
              keys[0].key_ops = ku.filter(isPubKeyUse), keys[1].key_ops = ku.filter(isPrvKeyUse);
              return Promise.all([
                _subtle.importKey("jwk", keys[0], ka, true, keys[0].key_ops),
                _subtle.importKey("jwk", keys[1], ka, kx, keys[1].key_ops)
              ]);
            }).then(function(keys) {
              return {
                publicKey: keys[0],
                privateKey: keys[1]
              };
            });
          }
          if ((isWebkit || isIE && (ka.hash || {}).name === "SHA-1") && m === "importKey" && a === "jwk" && ka.name === "HMAC" && b.kty === "oct") {
            return _subtle.importKey("raw", s2b(a2s(b.k)), c, args[3], args[4]);
          }
          if (isWebkit && m === "importKey" && (a === "spki" || a === "pkcs8")) {
            return _subtle.importKey("jwk", pkcs2jwk(b), c, args[3], args[4]);
          }
          if (isIE && m === "unwrapKey") {
            return _subtle.decrypt(args[3], c, b).then(function(k) {
              return _subtle.importKey(a, k, args[4], args[5], args[6]);
            });
          }
          var op;
          try {
            op = _fn.apply(_subtle, args);
          } catch (e) {
            return Promise.reject(e);
          }
          if (isIE) {
            op = new Promise(function(res, rej) {
              op.onabort = op.onerror = function(e) {
                rej(e);
              };
              op.oncomplete = function(r) {
                res(r.target.result);
              };
            });
          }
          op = op.then(function(k) {
            if (ka.name === "HMAC") {
              if (!ka.length) ka.length = 8 * k.algorithm.length;
            }
            if (ka.name.search("RSA") == 0) {
              if (!ka.modulusLength) ka.modulusLength = (k.publicKey || k).algorithm.modulusLength;
              if (!ka.publicExponent) ka.publicExponent = (k.publicKey || k).algorithm.publicExponent;
            }
            if (k.publicKey && k.privateKey) {
              k = {
                publicKey: new CryptoKey(k.publicKey, ka, kx, ku.filter(isPubKeyUse)),
                privateKey: new CryptoKey(k.privateKey, ka, kx, ku.filter(isPrvKeyUse))
              };
            } else {
              k = new CryptoKey(k, ka, kx, ku);
            }
            return k;
          });
          return op;
        };
      });
      ["exportKey", "wrapKey"].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c) {
          var args = [].slice.call(arguments);
          switch (m) {
            case "exportKey":
              args[1] = b._key;
              break;
            case "wrapKey":
              args[1] = b._key, args[2] = c._key;
              break;
          }
          if ((isWebkit || isIE && (b.algorithm.hash || {}).name === "SHA-1") && m === "exportKey" && a === "jwk" && b.algorithm.name === "HMAC") {
            args[0] = "raw";
          }
          if (isWebkit && m === "exportKey" && (a === "spki" || a === "pkcs8")) {
            args[0] = "jwk";
          }
          if (isIE && m === "wrapKey") {
            return _subtle.exportKey(a, b).then(function(k) {
              if (a === "jwk") k = s2b(unescape(encodeURIComponent(JSON.stringify(b2jwk(k)))));
              return _subtle.encrypt(args[3], c, k);
            });
          }
          var op;
          try {
            op = _fn.apply(_subtle, args);
          } catch (e) {
            return Promise.reject(e);
          }
          if (isIE) {
            op = new Promise(function(res, rej) {
              op.onabort = op.onerror = function(e) {
                rej(e);
              };
              op.oncomplete = function(r) {
                res(r.target.result);
              };
            });
          }
          if (m === "exportKey" && a === "jwk") {
            op = op.then(function(k) {
              if ((isWebkit || isIE && (b.algorithm.hash || {}).name === "SHA-1") && b.algorithm.name === "HMAC") {
                return { "kty": "oct", "alg": jwkAlg(b.algorithm), "key_ops": b.usages.slice(), "ext": true, "k": s2a(b2s(k)) };
              }
              k = b2jwk(k);
              if (!k.alg) k["alg"] = jwkAlg(b.algorithm);
              if (!k.key_ops) k["key_ops"] = b.type === "public" ? b.usages.filter(isPubKeyUse) : b.type === "private" ? b.usages.filter(isPrvKeyUse) : b.usages.slice();
              return k;
            });
          }
          if (isWebkit && m === "exportKey" && (a === "spki" || a === "pkcs8")) {
            op = op.then(function(k) {
              k = jwk2pkcs(b2jwk(k));
              return k;
            });
          }
          return op;
        };
      });
      ["encrypt", "decrypt", "sign", "verify"].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c, d) {
          if (isIE && (!c.byteLength || d && !d.byteLength))
            throw new Error("Empy input is not allowed");
          var args = [].slice.call(arguments), ka = alg(a);
          if (isIE && m === "decrypt" && ka.name === "AES-GCM") {
            var tl = a.tagLength >> 3;
            args[2] = (c.buffer || c).slice(0, c.byteLength - tl), a.tag = (c.buffer || c).slice(c.byteLength - tl);
          }
          args[1] = b._key;
          var op;
          try {
            op = _fn.apply(_subtle, args);
          } catch (e) {
            return Promise.reject(e);
          }
          if (isIE) {
            op = new Promise(function(res, rej) {
              op.onabort = op.onerror = function(e) {
                rej(e);
              };
              op.oncomplete = function(r) {
                var r = r.target.result;
                if (m === "encrypt" && r instanceof AesGcmEncryptResult) {
                  var c2 = r.ciphertext, t = r.tag;
                  r = new Uint8Array(c2.byteLength + t.byteLength);
                  r.set(new Uint8Array(c2), 0);
                  r.set(new Uint8Array(t), c2.byteLength);
                  r = r.buffer;
                }
                res(r);
              };
            });
          }
          return op;
        };
      });
      if (isIE) {
        var _digest = _subtle.digest;
        _subtle["digest"] = function(a, b) {
          if (!b.byteLength)
            throw new Error("Empy input is not allowed");
          var op;
          try {
            op = _digest.call(_subtle, a, b);
          } catch (e) {
            return Promise.reject(e);
          }
          op = new Promise(function(res, rej) {
            op.onabort = op.onerror = function(e) {
              rej(e);
            };
            op.oncomplete = function(r) {
              res(r.target.result);
            };
          });
          return op;
        };
        global2.crypto = Object.create(_crypto, {
          getRandomValues: { value: function(a) {
            return _crypto.getRandomValues(a);
          } },
          subtle: { value: _subtle }
        });
        global2.CryptoKey = CryptoKey;
      }
      if (isWebkit) {
        _crypto.subtle = _subtle;
        global2.Crypto = _Crypto;
        global2.SubtleCrypto = _SubtleCrypto;
        global2.CryptoKey = CryptoKey;
      }
    });
  }
});

// node_modules/isomorphic-webcrypto/src/browser.mjs
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var browser_default;
var init_browser = __esm({
  "node_modules/isomorphic-webcrypto/src/browser.mjs"() {
    init_webcrypto_shim();
    browser_default = window.crypto;
  }
});

// node_modules/fhirclient/lib/security/browser.js
var require_browser2 = __commonJS({
  "node_modules/fhirclient/lib/security/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.signCompactJws = exports.importJWK = exports.generatePKCEChallenge = exports.digestSha256 = exports.randomBytes = void 0;
    var js_base64_1 = require_base64();
    var crypto = typeof globalThis === "object" && globalThis.crypto ? globalThis.crypto : (init_browser(), __toCommonJS(browser_exports)).default;
    var subtle = () => {
      if (!crypto.subtle) {
        if (!globalThis.isSecureContext) {
          throw new Error("Some of the required subtle crypto functionality is not available unless you run this app in secure context (using HTTPS or running locally). See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts");
        }
        throw new Error("Some of the required subtle crypto functionality is not available in the current environment (no crypto.subtle)");
      }
      return crypto.subtle;
    };
    var ALGS = {
      ES384: {
        name: "ECDSA",
        namedCurve: "P-384"
      },
      RS384: {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: 4096,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: {
          name: "SHA-384"
        }
      }
    };
    function randomBytes(count) {
      return crypto.getRandomValues(new Uint8Array(count));
    }
    exports.randomBytes = randomBytes;
    async function digestSha256(payload) {
      const prepared = new TextEncoder().encode(payload);
      const hash = await subtle().digest("SHA-256", prepared);
      return new Uint8Array(hash);
    }
    exports.digestSha256 = digestSha256;
    var generatePKCEChallenge = async (entropy = 96) => {
      const inputBytes = randomBytes(entropy);
      const codeVerifier = (0, js_base64_1.fromUint8Array)(inputBytes, true);
      const codeChallenge = (0, js_base64_1.fromUint8Array)(await digestSha256(codeVerifier), true);
      return {
        codeChallenge,
        codeVerifier
      };
    };
    exports.generatePKCEChallenge = generatePKCEChallenge;
    async function importJWK(jwk) {
      if (!jwk.alg) {
        throw new Error('The "alg" property of the JWK must be set to "ES384" or "RS384"');
      }
      if (!Array.isArray(jwk.key_ops)) {
        jwk.key_ops = ["sign"];
      }
      if (!jwk.key_ops.includes("sign")) {
        throw new Error('The "key_ops" property of the JWK does not contain "sign"');
      }
      try {
        return await subtle().importKey(
          "jwk",
          jwk,
          ALGS[jwk.alg],
          jwk.ext === true,
          jwk.key_ops
          // || ['sign']
        );
      } catch (e) {
        throw new Error(`The ${jwk.alg} is not supported by this browser: ${e}`);
      }
    }
    exports.importJWK = importJWK;
    async function signCompactJws(alg, privateKey, header, payload) {
      const jwtHeader = JSON.stringify(Object.assign(Object.assign({}, header), {
        alg
      }));
      const jwtPayload = JSON.stringify(payload);
      const jwtAuthenticatedContent = `${(0, js_base64_1.encodeURL)(jwtHeader)}.${(0, js_base64_1.encodeURL)(jwtPayload)}`;
      const signature = await subtle().sign(Object.assign(Object.assign({}, privateKey.algorithm), {
        hash: "SHA-384"
      }), privateKey, new TextEncoder().encode(jwtAuthenticatedContent));
      return `${jwtAuthenticatedContent}.${(0, js_base64_1.fromUint8Array)(new Uint8Array(signature), true)}`;
    }
    exports.signCompactJws = signCompactJws;
  }
});

// node_modules/fhirclient/lib/adapters/BrowserAdapter.js
var require_BrowserAdapter = __commonJS({
  "node_modules/fhirclient/lib/adapters/BrowserAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var smart_1 = require_smart();
    var Client_1 = require_Client();
    var BrowserStorage_1 = require_BrowserStorage();
    var security = require_browser2();
    var js_base64_1 = require_base64();
    var BrowserAdapter = class {
      /**
       * @param options Environment-specific options
       */
      constructor(options = {}) {
        this._url = null;
        this._storage = null;
        this.security = security;
        this.options = Object.assign({
          // Replaces the browser's current URL
          // using window.history.replaceState API or by reloading.
          replaceBrowserHistory: true,
          // When set to true, this variable will fully utilize
          // HTML5 sessionStorage API.
          // This variable can be overridden to false by setting
          // FHIR.oauth2.settings.fullSessionStorageSupport = false.
          // When set to false, the sessionStorage will be keyed
          // by a state variable. This is to allow the embedded IE browser
          // instances instantiated on a single thread to continue to
          // function without having sessionStorage data shared
          // across the embedded IE instances.
          fullSessionStorageSupport: true,
          // Do we want to send cookies while making a request to the token
          // endpoint in order to obtain new access token using existing
          // refresh token. In rare cases the auth server might require the
          // client to send cookies along with those requests. In this case
          // developers will have to change this before initializing the app
          // like so:
          // `FHIR.oauth2.settings.refreshTokenWithCredentials = "include";`
          // or
          // `FHIR.oauth2.settings.refreshTokenWithCredentials = "same-origin";`
          // Can be one of:
          // "include"     - always send cookies
          // "same-origin" - only send cookies if we are on the same domain (default)
          // "omit"        - do not send cookies
          refreshTokenWithCredentials: "same-origin"
        }, options);
      }
      /**
       * Given a relative path, returns an absolute url using the instance base URL
       */
      relative(path) {
        return new URL(path, this.getUrl().href).href;
      }
      /**
       * In browsers we need to be able to (dynamically) check if fhir.js is
       * included in the page. If it is, it should have created a "fhir" variable
       * in the global scope.
       */
      get fhir() {
        return typeof fhir === "function" ? fhir : null;
      }
      /**
       * Given the current environment, this method must return the current url
       * as URL instance
       */
      getUrl() {
        if (!this._url) {
          this._url = new URL(location + "");
        }
        return this._url;
      }
      /**
       * Given the current environment, this method must redirect to the given
       * path
       */
      redirect(to) {
        location.href = to;
      }
      /**
       * Returns a BrowserStorage object which is just a wrapper around
       * sessionStorage
       */
      getStorage() {
        if (!this._storage) {
          this._storage = new BrowserStorage_1.default();
        }
        return this._storage;
      }
      /**
       * Returns a reference to the AbortController constructor. In browsers,
       * AbortController will always be available as global (native or polyfilled)
       */
      getAbortController() {
        return AbortController;
      }
      /**
       * ASCII string to Base64
       */
      atob(str) {
        return window.atob(str);
      }
      /**
       * Base64 to ASCII string
       */
      btoa(str) {
        return window.btoa(str);
      }
      base64urlencode(input) {
        if (typeof input == "string") {
          return (0, js_base64_1.encodeURL)(input);
        }
        return (0, js_base64_1.fromUint8Array)(input, true);
      }
      base64urldecode(input) {
        return (0, js_base64_1.decode)(input);
      }
      /**
       * Creates and returns adapter-aware SMART api. Not that while the shape of
       * the returned object is well known, the arguments to this function are not.
       * Those who override this method are free to require any environment-specific
       * arguments. For example in node we will need a request, a response and
       * optionally a storage or storage factory function.
       */
      getSmartApi() {
        return {
          ready: (...args) => (0, smart_1.ready)(this, ...args),
          authorize: (options) => (0, smart_1.authorize)(this, options),
          init: (options) => (0, smart_1.init)(this, options),
          client: (state) => new Client_1.default(this, state),
          options: this.options,
          utils: {
            security
          }
        };
      }
    };
    exports.default = BrowserAdapter;
  }
});

// node_modules/abortcontroller-polyfill/dist/abortcontroller-polyfill-only.js
var require_abortcontroller_polyfill_only = __commonJS({
  "node_modules/abortcontroller-polyfill/dist/abortcontroller-polyfill-only.js"() {
    (function(factory) {
      typeof define === "function" && define.amd ? define(factory) : factory();
    })(function() {
      "use strict";
      function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      function _callSuper(t, o, e) {
        return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
      }
      function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
        }
      }
      function _createClass(e, r, t) {
        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
          writable: false
        }), e;
      }
      function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var n = 0, F = function() {
            };
            return {
              s: F,
              n: function() {
                return n >= r.length ? {
                  done: true
                } : {
                  done: false,
                  value: r[n++]
                };
              },
              e: function(r2) {
                throw r2;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = true, u = false;
        return {
          s: function() {
            t = t.call(r);
          },
          n: function() {
            var r2 = t.next();
            return a = r2.done, r2;
          },
          e: function(r2) {
            u = true, o = r2;
          },
          f: function() {
            try {
              a || null == t.return || t.return();
            } finally {
              if (u) throw o;
            }
          }
        };
      }
      function _get() {
        return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
          var p = _superPropBase(e, t);
          if (p) {
            var n = Object.getOwnPropertyDescriptor(p, t);
            return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
          }
        }, _get.apply(null, arguments);
      }
      function _getPrototypeOf(t) {
        return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
          return t2.__proto__ || Object.getPrototypeOf(t2);
        }, _getPrototypeOf(t);
      }
      function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: true,
            configurable: true
          }
        }), Object.defineProperty(t, "prototype", {
          writable: false
        }), e && _setPrototypeOf(t, e);
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function() {
          return !!t;
        })();
      }
      function _possibleConstructorReturn(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return _assertThisInitialized(t);
      }
      function _setPrototypeOf(t, e) {
        return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
          return t2.__proto__ = e2, t2;
        }, _setPrototypeOf(t, e);
      }
      function _superPropBase(t, o) {
        for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
        return t;
      }
      function _superPropGet(t, o, e, r) {
        var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t2) {
          return p.apply(e, t2);
        } : p;
      }
      function _toPrimitive(t, r) {
        if ("object" != typeof t || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != typeof i) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      function _toPropertyKey(t) {
        var i = _toPrimitive(t, "string");
        return "symbol" == typeof i ? i : i + "";
      }
      function _unsupportedIterableToArray(r, a) {
        if (r) {
          if ("string" == typeof r) return _arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
      }
      (function(self2) {
        return {
          NativeAbortSignal: self2.AbortSignal,
          NativeAbortController: self2.AbortController
        };
      })(typeof self !== "undefined" ? self : global);
      function createAbortEvent(reason) {
        var event;
        try {
          event = new Event("abort");
        } catch (e) {
          if (typeof document !== "undefined") {
            if (!document.createEvent) {
              event = document.createEventObject();
              event.type = "abort";
            } else {
              event = document.createEvent("Event");
              event.initEvent("abort", false, false);
            }
          } else {
            event = {
              type: "abort",
              bubbles: false,
              cancelable: false
            };
          }
        }
        event.reason = reason;
        return event;
      }
      function normalizeAbortReason(reason) {
        if (reason === void 0) {
          if (typeof document === "undefined") {
            reason = new Error("This operation was aborted");
            reason.name = "AbortError";
          } else {
            try {
              reason = new DOMException("signal is aborted without reason");
              Object.defineProperty(reason, "name", {
                value: "AbortError"
              });
            } catch (err) {
              reason = new Error("This operation was aborted");
              reason.name = "AbortError";
            }
          }
        }
        return reason;
      }
      var Emitter = function() {
        function Emitter2() {
          _classCallCheck(this, Emitter2);
          Object.defineProperty(this, "listeners", {
            value: {},
            writable: true,
            configurable: true
          });
        }
        return _createClass(Emitter2, [{
          key: "addEventListener",
          value: function addEventListener(type, callback, options) {
            if (!(type in this.listeners)) {
              this.listeners[type] = [];
            }
            this.listeners[type].push({
              callback,
              options
            });
          }
        }, {
          key: "removeEventListener",
          value: function removeEventListener(type, callback) {
            if (!(type in this.listeners)) {
              return;
            }
            var stack = this.listeners[type];
            for (var i = 0, l = stack.length; i < l; i++) {
              if (stack[i].callback === callback) {
                stack.splice(i, 1);
                return;
              }
            }
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(event) {
            var _this = this;
            if (!(event.type in this.listeners)) {
              return;
            }
            var stack = this.listeners[event.type];
            var stackToCall = stack.slice();
            var _loop = function _loop2() {
              var listener = stackToCall[i];
              try {
                listener.callback.call(_this, event);
              } catch (e) {
                Promise.resolve().then(function() {
                  throw e;
                });
              }
              if (listener.options && listener.options.once) {
                _this.removeEventListener(event.type, listener.callback);
              }
            };
            for (var i = 0, l = stackToCall.length; i < l; i++) {
              _loop();
            }
            return !event.defaultPrevented;
          }
        }]);
      }();
      var AbortSignal = function(_Emitter) {
        function AbortSignal2() {
          var _this2;
          _classCallCheck(this, AbortSignal2);
          _this2 = _callSuper(this, AbortSignal2);
          if (!_this2.listeners) {
            Emitter.call(_this2);
          }
          Object.defineProperty(_this2, "aborted", {
            value: false,
            writable: true,
            configurable: true
          });
          Object.defineProperty(_this2, "onabort", {
            value: null,
            writable: true,
            configurable: true
          });
          Object.defineProperty(_this2, "reason", {
            value: void 0,
            writable: true,
            configurable: true
          });
          return _this2;
        }
        _inherits(AbortSignal2, _Emitter);
        return _createClass(AbortSignal2, [{
          key: "toString",
          value: function toString() {
            return "[object AbortSignal]";
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(event) {
            if (event.type === "abort") {
              this.aborted = true;
              if (typeof this.onabort === "function") {
                this.onabort.call(this, event);
              }
            }
            _superPropGet(AbortSignal2, "dispatchEvent", this, 3)([event]);
          }
          /**
           * @see {@link https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal/throwIfAborted}
           */
        }, {
          key: "throwIfAborted",
          value: function throwIfAborted() {
            var aborted = this.aborted, _this$reason = this.reason, reason = _this$reason === void 0 ? "Aborted" : _this$reason;
            if (!aborted) return;
            throw reason;
          }
          /**
           * @see {@link https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal/timeout_static}
           * @param {number} time The "active" time in milliseconds before the returned {@link AbortSignal} will abort.
           *                      The value must be within range of 0 and {@link Number.MAX_SAFE_INTEGER}.
           * @returns {AbortSignal} The signal will abort with its {@link AbortSignal.reason} property set to a `TimeoutError` {@link DOMException} on timeout,
           *                        or an `AbortError` {@link DOMException} if the operation was user-triggered.
           */
        }], [{
          key: "timeout",
          value: function timeout(time) {
            var controller = new AbortController2();
            setTimeout(function() {
              return controller.abort(new DOMException("This signal is timeout in ".concat(time, "ms"), "TimeoutError"));
            }, time);
            return controller.signal;
          }
          /**
           * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static}
           * @param {Iterable<AbortSignal>} iterable An {@link Iterable} (such as an {@link Array}) of abort signals.
           * @returns {AbortSignal} - **Already aborted**, if any of the abort signals given is already aborted.
           *                          The returned {@link AbortSignal}'s reason will be already set to the `reason` of the first abort signal that was already aborted.
           *                        - **Asynchronously aborted**, when any abort signal in `iterable` aborts.
           *                          The `reason` will be set to the reason of the first abort signal that is aborted.
           */
        }, {
          key: "any",
          value: function any(iterable) {
            var controller = new AbortController2();
            function abort() {
              controller.abort(this.reason);
              clean();
            }
            function clean() {
              var _iterator = _createForOfIteratorHelper(iterable), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var signal2 = _step.value;
                  signal2.removeEventListener("abort", abort);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
            var _iterator2 = _createForOfIteratorHelper(iterable), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var signal = _step2.value;
                if (signal.aborted) {
                  controller.abort(signal.reason);
                  break;
                } else signal.addEventListener("abort", abort);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            return controller.signal;
          }
        }]);
      }(Emitter);
      var AbortController2 = function() {
        function AbortController3() {
          _classCallCheck(this, AbortController3);
          Object.defineProperty(this, "signal", {
            value: new AbortSignal(),
            writable: true,
            configurable: true
          });
        }
        return _createClass(AbortController3, [{
          key: "abort",
          value: function abort(reason) {
            var signalReason = normalizeAbortReason(reason);
            var event = createAbortEvent(signalReason);
            this.signal.reason = signalReason;
            this.signal.dispatchEvent(event);
          }
        }, {
          key: "toString",
          value: function toString() {
            return "[object AbortController]";
          }
        }]);
      }();
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        AbortController2.prototype[Symbol.toStringTag] = "AbortController";
        AbortSignal.prototype[Symbol.toStringTag] = "AbortSignal";
      }
      function polyfillNeeded(self2) {
        if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
          console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
          return true;
        }
        return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
      }
      (function(self2) {
        if (!polyfillNeeded(self2)) {
          return;
        }
        self2.AbortController = AbortController2;
        self2.AbortSignal = AbortSignal;
      })(typeof self !== "undefined" ? self : global);
    });
  }
});

// node_modules/fhirclient/lib/entry/browser.js
var require_browser3 = __commonJS({
  "node_modules/fhirclient/lib/entry/browser.js"(exports, module2) {
    var BrowserAdapter_1 = require_BrowserAdapter();
    var FhirClient_1 = require_FhirClient();
    var adapter = new BrowserAdapter_1.default();
    var {
      ready,
      authorize,
      init,
      client,
      options,
      utils
    } = adapter.getSmartApi();
    if (typeof FHIRCLIENT_PURE == "undefined") {
      const fetch = require_browser_ponyfill();
      require_abortcontroller_polyfill_only();
      if (!window.fetch) {
        window.fetch = fetch.default;
        window.Headers = fetch.Headers;
        window.Request = fetch.Request;
        window.Response = fetch.Response;
      }
    }
    var FHIR = {
      AbortController: window.AbortController,
      client,
      /**
       * Using this class if you are connecting to open server that does not
       * require authorization.
       */
      FhirClient: FhirClient_1.default,
      utils,
      oauth2: {
        settings: options,
        ready,
        authorize,
        init
      }
    };
    module2.exports = FHIR;
  }
});
export default require_browser3();
/*! Bundled license information:

isomorphic-webcrypto/src/webcrypto-shim.mjs:
  (**
   * @file Web Cryptography API shim
   * @author Artem S Vybornov <vybornov@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=fhirclient.js.map
